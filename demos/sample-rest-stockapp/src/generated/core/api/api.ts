/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BatchRead
 */
export interface BatchRead {
    /**
     * List of bins to limit the record response to.
     * @type {Array<string>}
     * @memberof BatchRead
     */
    binNames?: Array<string>;
    /**
     * Key to retrieve a record
     * @type {Key}
     * @memberof BatchRead
     */
    key?: Key;
    /**
     * Whether all bins should be returned with this record
     * @type {boolean}
     * @memberof BatchRead
     */
    readAllBins?: boolean;
    /**
     * Record associated with the key. Null if the record was not found
     * @type {Record}
     * @memberof BatchRead
     */
    record?: Record;
}
/**
 * 
 * @export
 * @interface BatchReadRequest
 */
export interface BatchReadRequest {
    /**
     * List of bins to limit the record response to.
     * @type {Array<string>}
     * @memberof BatchReadRequest
     */
    binNames?: Array<string>;
    /**
     * Key to retrieve a record
     * @type {Key}
     * @memberof BatchReadRequest
     */
    key: Key;
    /**
     * Whether all bins should be returned with this record
     * @type {boolean}
     * @memberof BatchReadRequest
     */
    readAllBins?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterInformation
 */
export interface ClusterInformation {
    /**
     * 
     * @type {Array<NamespaceInformation>}
     * @memberof ClusterInformation
     */
    namespaces?: Array<NamespaceInformation>;
    /**
     * 
     * @type {Array<NodeInformation>}
     * @memberof ClusterInformation
     */
    nodes?: Array<NodeInformation>;
}
/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * URL safe base64 encoded key digest. Returned by the server on batch responses. May be provided by client.
     * @type {string}
     * @memberof Key
     */
    digest?: string;
    /**
     * Enum describing the type of the userKey. This field is omitted in MessagePack responses.
     * @type {string}
     * @memberof Key
     */
    keytype?: KeyKeytypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    namespace: string;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    setName?: string;
    /**
     * The user key, it may be a string, integer, or URL safe Base64 encoded bytes.
     * @type {any}
     * @memberof Key
     */
    userKey?: any;
}

/**
 * @export
 * @namespace Key
 */
// export namespace Key {
    /**
     * @export
     * @enum {string}
     */
    export enum KeyKeytypeEnum {
        STRING = 'STRING' as any ,
        INTEGER = 'INTEGER' as any ,
        BYTES = 'BYTES' as any ,
        DIGEST = 'DIGEST' as any 
    }
//}

/**
 * 
 * @export
 * @interface NamespaceInformation
 */
export interface NamespaceInformation {
    /**
     * 
     * @type {string}
     * @memberof NamespaceInformation
     */
    name?: string;
    /**
     * 
     * @type {Array<RestClientSetInformation>}
     * @memberof NamespaceInformation
     */
    sets?: Array<RestClientSetInformation>;
}
/**
 * 
 * @export
 * @interface NodeInformation
 */
export interface NodeInformation {
    /**
     * 
     * @type {string}
     * @memberof NodeInformation
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * 
     * @type {any}
     * @memberof Operation
     */
    opValues: any;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    operation: string;
}
/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    code: PrivilegeCodeEnum;
    /**
     * Namespace Scope
     * @type {string}
     * @memberof Privilege
     */
    namespace?: string;
    /**
     * setName Scope
     * @type {string}
     * @memberof Privilege
     */
    set?: string;
}

/**
 * @export
 * @namespace Privilege
 */
// export namespace Privilege {
    /**
     * @export
     * @enum {string}
     */
    export enum PrivilegeCodeEnum {
        UserAdmin = 'user-admin' as any ,
        SysAdmin = 'sys-admin' as any ,
        DataAdmin = 'data-admin' as any ,
        Read = 'read' as any ,
        ReadWrite = 'read-write' as any ,
        ReadWriteUdf = 'read-write-udf' as any 
    }
//}

/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * A mapping from binName to binValue
     * @type {any}
     * @memberof Record
     */
    bins?: any;
    /**
     * The generation of the record.
     * @type {number}
     * @memberof Record
     */
    generation?: number;
    /**
     * The time to live for the record, in seconds from now.
     * @type {number}
     * @memberof Record
     */
    ttl?: number;
}
/**
 * Error object returned from unsuccesful operations.
 * @export
 * @interface RestClientError
 */
export interface RestClientError {
    /**
     * A boolean specifying whether it was possible that the operation succeeded. This is only included if true.
     * @type {boolean}
     * @memberof RestClientError
     */
    inDoubt?: boolean;
    /**
     * An internal error code for diagnostic purposes. This may be null
     * @type {number}
     * @memberof RestClientError
     */
    internalErrorCode?: number;
    /**
     * A message describing the cause of the error.
     * @type {string}
     * @memberof RestClientError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface RestClientIndex
 */
export interface RestClientIndex {
    /**
     * The bin which is indexed
     * @type {string}
     * @memberof RestClientIndex
     */
    bin?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    collectionType?: RestClientIndexCollectionTypeEnum;
    /**
     * The name of the index. This must be unique per set
     * @type {string}
     * @memberof RestClientIndex
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    set?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    type?: RestClientIndexTypeEnum;
}

/**
 * @export
 * @namespace RestClientIndex
 */
// export namespace RestClientIndex {
    /**
     * @export
     * @enum {string}
     */
    export enum RestClientIndexCollectionTypeEnum {
        DEFAULT = 'DEFAULT' as any ,
        LIST = 'LIST' as any ,
        MAPKEYS = 'MAPKEYS' as any ,
        MAPVALUES = 'MAPVALUES' as any 
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestClientIndexTypeEnum {
        NUMERIC = 'NUMERIC' as any ,
        STRING = 'STRING' as any ,
        GEO2DSPHERE = 'GEO2DSPHERE' as any 
    }
//}

/**
 * 
 * @export
 * @interface RestClientRole
 */
export interface RestClientRole {
    /**
     * 
     * @type {string}
     * @memberof RestClientRole
     */
    name?: string;
    /**
     * 
     * @type {Array<Privilege>}
     * @memberof RestClientRole
     */
    privileges?: Array<Privilege>;
}
/**
 * 
 * @export
 * @interface RestClientSetInformation
 */
export interface RestClientSetInformation {
    /**
     * 
     * @type {string}
     * @memberof RestClientSetInformation
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof RestClientSetInformation
     */
    objectCount?: number;
}
/**
 * 
 * @export
 * @interface RestClientUserModel
 */
export interface RestClientUserModel {
    /**
     * 
     * @type {string}
     * @memberof RestClientUserModel
     */
    password?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RestClientUserModel
     */
    roles?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RestClientUserModel
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<string>;
}

/**
 * AdminOperationsApi - fetch parameter creator
 * @export
 */
export const AdminOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change the password of the specified user.
         * @param {string} password password
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(password: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling changePassword.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling changePassword.');
            }
            const localVarPath = `/v1/admin/user/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("string" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(password || {}) : (password || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a role on the Aerospike cluster.
         * @param {RestClientRole} rcRole rcRole
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(rcRole: RestClientRole, options: any = {}): FetchArgs {
            // verify required parameter 'rcRole' is not null or undefined
            if (rcRole === null || rcRole === undefined) {
                throw new RequiredError('rcRole','Required parameter rcRole was null or undefined when calling createRole.');
            }
            const localVarPath = `/v1/admin/role`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RestClientRole" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rcRole || {}) : (rcRole || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {RestClientUserModel} userInfo userInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userInfo: RestClientUserModel, options: any = {}): FetchArgs {
            // verify required parameter 'userInfo' is not null or undefined
            if (userInfo === null || userInfo === undefined) {
                throw new RequiredError('userInfo','Required parameter userInfo was null or undefined when calling createUser.');
            }
            const localVarPath = `/v1/admin/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RestClientUserModel" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(userInfo || {}) : (userInfo || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a specific role from the Aerospike cluster.
         * @param {string} name The name of the role to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropRole(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling dropRole.');
            }
            const localVarPath = `/v1/admin/role/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user.
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropUser(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling dropUser.');
            }
            const localVarPath = `/v1/admin/user/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a specific role.
         * @param {string} name The name of the role whose information should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRole.');
            }
            const localVarPath = `/v1/admin/role/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a list of all roles registered with the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options: any = {}): FetchArgs {
            const localVarPath = `/v1/admin/role`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return information about a specific user.
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getUser.');
            }
            const localVarPath = `/v1/admin/user/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a list of information about users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options: any = {}): FetchArgs {
            const localVarPath = `/v1/admin/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant a list of privileges to a specific role.
         * @param {string} name The name of the role to which privileges will be granted.
         * @param {Array<Privilege>} privileges privileges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPrivileges(name: string, privileges: Array<Privilege>, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling grantPrivileges.');
            }
            // verify required parameter 'privileges' is not null or undefined
            if (privileges === null || privileges === undefined) {
                throw new RequiredError('privileges','Required parameter privileges was null or undefined when calling grantPrivileges.');
            }
            const localVarPath = `/v1/admin/role/{name}/privilege`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Privilege&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(privileges || {}) : (privileges || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant a set of roles to the specified user.
         * @param {Array<string>} roles roles
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRoles(roles: Array<string>, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling grantRoles.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling grantRoles.');
            }
            const localVarPath = `/v1/admin/user/{user}/role`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;string&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(roles || {}) : (roles || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a list of privileges from a specific role.
         * @param {string} name The name of the role from which privileges will be removed.
         * @param {Array<Privilege>} privileges privileges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePrivileges(name: string, privileges: Array<Privilege>, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling revokePrivileges.');
            }
            // verify required parameter 'privileges' is not null or undefined
            if (privileges === null || privileges === undefined) {
                throw new RequiredError('privileges','Required parameter privileges was null or undefined when calling revokePrivileges.');
            }
            const localVarPath = `/v1/admin/role/{name}/privilege/delete`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Privilege&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(privileges || {}) : (privileges || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke a set of roles from the specified user.
         * @param {Array<string>} roles A list of names to revoke from the user
         * @param {string} user The user from which to revoke roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeRoles(roles: Array<string>, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling revokeRoles.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling revokeRoles.');
            }
            const localVarPath = `/v1/admin/user/{user}/role/delete`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;string&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(roles || {}) : (roles || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminOperationsApi - functional programming interface
 * @export
 */
export const AdminOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change the password of the specified user.
         * @param {string} password password
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(password: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).changePassword(password, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a role on the Aerospike cluster.
         * @param {RestClientRole} rcRole rcRole
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(rcRole: RestClientRole, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).createRole(rcRole, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {RestClientUserModel} userInfo userInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userInfo: RestClientUserModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).createUser(userInfo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a specific role from the Aerospike cluster.
         * @param {string} name The name of the role to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropRole(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).dropRole(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a user.
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropUser(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).dropUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get information about a specific role.
         * @param {string} name The name of the role whose information should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RestClientRole> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).getRole(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return a list of all roles registered with the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RestClientRole>> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).getRoles(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return information about a specific user.
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).getUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return a list of information about users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).getUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Grant a list of privileges to a specific role.
         * @param {string} name The name of the role to which privileges will be granted.
         * @param {Array<Privilege>} privileges privileges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPrivileges(name: string, privileges: Array<Privilege>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).grantPrivileges(name, privileges, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Grant a set of roles to the specified user.
         * @param {Array<string>} roles roles
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRoles(roles: Array<string>, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).grantRoles(roles, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a list of privileges from a specific role.
         * @param {string} name The name of the role from which privileges will be removed.
         * @param {Array<Privilege>} privileges privileges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePrivileges(name: string, privileges: Array<Privilege>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).revokePrivileges(name, privileges, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Revoke a set of roles from the specified user.
         * @param {Array<string>} roles A list of names to revoke from the user
         * @param {string} user The user from which to revoke roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeRoles(roles: Array<string>, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminOperationsApiFetchParamCreator(configuration).revokeRoles(roles, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminOperationsApi - factory interface
 * @export
 */
export const AdminOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change the password of the specified user.
         * @param {string} password password
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(password: string, user: string, options?: any) {
            return AdminOperationsApiFp(configuration).changePassword(password, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a role on the Aerospike cluster.
         * @param {RestClientRole} rcRole rcRole
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(rcRole: RestClientRole, options?: any) {
            return AdminOperationsApiFp(configuration).createRole(rcRole, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new user.
         * @param {RestClientUserModel} userInfo userInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userInfo: RestClientUserModel, options?: any) {
            return AdminOperationsApiFp(configuration).createUser(userInfo, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a specific role from the Aerospike cluster.
         * @param {string} name The name of the role to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropRole(name: string, options?: any) {
            return AdminOperationsApiFp(configuration).dropRole(name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a user.
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropUser(user: string, options?: any) {
            return AdminOperationsApiFp(configuration).dropUser(user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get information about a specific role.
         * @param {string} name The name of the role whose information should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(name: string, options?: any) {
            return AdminOperationsApiFp(configuration).getRole(name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return a list of all roles registered with the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any) {
            return AdminOperationsApiFp(configuration).getRoles(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return information about a specific user.
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options?: any) {
            return AdminOperationsApiFp(configuration).getUser(user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return a list of information about users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any) {
            return AdminOperationsApiFp(configuration).getUsers(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Grant a list of privileges to a specific role.
         * @param {string} name The name of the role to which privileges will be granted.
         * @param {Array<Privilege>} privileges privileges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPrivileges(name: string, privileges: Array<Privilege>, options?: any) {
            return AdminOperationsApiFp(configuration).grantPrivileges(name, privileges, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Grant a set of roles to the specified user.
         * @param {Array<string>} roles roles
         * @param {string} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantRoles(roles: Array<string>, user: string, options?: any) {
            return AdminOperationsApiFp(configuration).grantRoles(roles, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a list of privileges from a specific role.
         * @param {string} name The name of the role from which privileges will be removed.
         * @param {Array<Privilege>} privileges privileges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePrivileges(name: string, privileges: Array<Privilege>, options?: any) {
            return AdminOperationsApiFp(configuration).revokePrivileges(name, privileges, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Revoke a set of roles from the specified user.
         * @param {Array<string>} roles A list of names to revoke from the user
         * @param {string} user The user from which to revoke roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeRoles(roles: Array<string>, user: string, options?: any) {
            return AdminOperationsApiFp(configuration).revokeRoles(roles, user, options)(fetch, basePath);
        },
    };
};

/**
 * AdminOperationsApi - object-oriented interface
 * @export
 * @class AdminOperationsApi
 * @extends {BaseAPI}
 */
export class AdminOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Change the password of the specified user.
     * @param {string} password password
     * @param {string} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public changePassword(password: string, user: string, options?: any) {
        return AdminOperationsApiFp(this.configuration).changePassword(password, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a role on the Aerospike cluster.
     * @param {RestClientRole} rcRole rcRole
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public createRole(rcRole: RestClientRole, options?: any) {
        return AdminOperationsApiFp(this.configuration).createRole(rcRole, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new user.
     * @param {RestClientUserModel} userInfo userInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public createUser(userInfo: RestClientUserModel, options?: any) {
        return AdminOperationsApiFp(this.configuration).createUser(userInfo, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a specific role from the Aerospike cluster.
     * @param {string} name The name of the role to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public dropRole(name: string, options?: any) {
        return AdminOperationsApiFp(this.configuration).dropRole(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a user.
     * @param {string} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public dropUser(user: string, options?: any) {
        return AdminOperationsApiFp(this.configuration).dropUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get information about a specific role.
     * @param {string} name The name of the role whose information should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public getRole(name: string, options?: any) {
        return AdminOperationsApiFp(this.configuration).getRole(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return a list of all roles registered with the Aerospike cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public getRoles(options?: any) {
        return AdminOperationsApiFp(this.configuration).getRoles(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return information about a specific user.
     * @param {string} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public getUser(user: string, options?: any) {
        return AdminOperationsApiFp(this.configuration).getUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return a list of information about users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public getUsers(options?: any) {
        return AdminOperationsApiFp(this.configuration).getUsers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Grant a list of privileges to a specific role.
     * @param {string} name The name of the role to which privileges will be granted.
     * @param {Array<Privilege>} privileges privileges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public grantPrivileges(name: string, privileges: Array<Privilege>, options?: any) {
        return AdminOperationsApiFp(this.configuration).grantPrivileges(name, privileges, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Grant a set of roles to the specified user.
     * @param {Array<string>} roles roles
     * @param {string} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public grantRoles(roles: Array<string>, user: string, options?: any) {
        return AdminOperationsApiFp(this.configuration).grantRoles(roles, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a list of privileges from a specific role.
     * @param {string} name The name of the role from which privileges will be removed.
     * @param {Array<Privilege>} privileges privileges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public revokePrivileges(name: string, privileges: Array<Privilege>, options?: any) {
        return AdminOperationsApiFp(this.configuration).revokePrivileges(name, privileges, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Revoke a set of roles from the specified user.
     * @param {Array<string>} roles A list of names to revoke from the user
     * @param {string} user The user from which to revoke roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminOperationsApi
     */
    public revokeRoles(roles: Array<string>, user: string, options?: any) {
        return AdminOperationsApiFp(this.configuration).revokeRoles(roles, user, options)(this.fetch, this.basePath);
    }

}

/**
 * BatchReadOperationsApi - fetch parameter creator
 * @export
 */
export const BatchReadOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return multiple records from the server in a single request.
         * @param {Array<BatchReadRequest>} batchKeys batchKeys
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performBatchGet(batchKeys: Array<BatchReadRequest>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'batchKeys' is not null or undefined
            if (batchKeys === null || batchKeys === undefined) {
                throw new RequiredError('batchKeys','Required parameter batchKeys was null or undefined when calling performBatchGet.');
            }
            const localVarPath = `/v1/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;BatchReadRequest&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(batchKeys || {}) : (batchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchReadOperationsApi - functional programming interface
 * @export
 */
export const BatchReadOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return multiple records from the server in a single request.
         * @param {Array<BatchReadRequest>} batchKeys batchKeys
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performBatchGet(batchKeys: Array<BatchReadRequest>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BatchRead>> {
            const localVarFetchArgs = BatchReadOperationsApiFetchParamCreator(configuration).performBatchGet(batchKeys, consistencyLevel, linearizeRead, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BatchReadOperationsApi - factory interface
 * @export
 */
export const BatchReadOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Return multiple records from the server in a single request.
         * @param {Array<BatchReadRequest>} batchKeys batchKeys
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performBatchGet(batchKeys: Array<BatchReadRequest>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return BatchReadOperationsApiFp(configuration).performBatchGet(batchKeys, consistencyLevel, linearizeRead, replica, sendKey, options)(fetch, basePath);
        },
    };
};

/**
 * BatchReadOperationsApi - object-oriented interface
 * @export
 * @class BatchReadOperationsApi
 * @extends {BaseAPI}
 */
export class BatchReadOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Return multiple records from the server in a single request.
     * @param {Array<BatchReadRequest>} batchKeys batchKeys
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchReadOperationsApi
     */
    public performBatchGet(batchKeys: Array<BatchReadRequest>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return BatchReadOperationsApiFp(this.configuration).performBatchGet(batchKeys, consistencyLevel, linearizeRead, replica, sendKey, options)(this.fetch, this.basePath);
    }

}

/**
 * ClusterInformationOperationsApi - fetch parameter creator
 * @export
 */
export const ClusterInformationOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return an object containing information about the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterInfo(options: any = {}): FetchArgs {
            const localVarPath = `/v1/cluster`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterInformationOperationsApi - functional programming interface
 * @export
 */
export const ClusterInformationOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return an object containing information about the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClusterInformation> {
            const localVarFetchArgs = ClusterInformationOperationsApiFetchParamCreator(configuration).getClusterInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClusterInformationOperationsApi - factory interface
 * @export
 */
export const ClusterInformationOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Return an object containing information about the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterInfo(options?: any) {
            return ClusterInformationOperationsApiFp(configuration).getClusterInfo(options)(fetch, basePath);
        },
    };
};

/**
 * ClusterInformationOperationsApi - object-oriented interface
 * @export
 * @class ClusterInformationOperationsApi
 * @extends {BaseAPI}
 */
export class ClusterInformationOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Return an object containing information about the Aerospike cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterInformationOperationsApi
     */
    public getClusterInfo(options?: any) {
        return ClusterInformationOperationsApiFp(this.configuration).getClusterInfo(options)(this.fetch, this.basePath);
    }

}

/**
 * InfoOperationsApi - fetch parameter creator
 * @export
 */
export const InfoOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send a list of info commands to a random node in the cluster
         * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoAny(infoRequests: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'infoRequests' is not null or undefined
            if (infoRequests === null || infoRequests === undefined) {
                throw new RequiredError('infoRequests','Required parameter infoRequests was null or undefined when calling infoAny.');
            }
            const localVarPath = `/v1/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;string&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(infoRequests || {}) : (infoRequests || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a list of info commands to a specific node in the cluster.
         * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
         * @param {string} nodeName The node ID for the node which will receive the info commands.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoNode(infoRequests: Array<string>, nodeName: string, options: any = {}): FetchArgs {
            // verify required parameter 'infoRequests' is not null or undefined
            if (infoRequests === null || infoRequests === undefined) {
                throw new RequiredError('infoRequests','Required parameter infoRequests was null or undefined when calling infoNode.');
            }
            // verify required parameter 'nodeName' is not null or undefined
            if (nodeName === null || nodeName === undefined) {
                throw new RequiredError('nodeName','Required parameter nodeName was null or undefined when calling infoNode.');
            }
            const localVarPath = `/v1/info/{node}`
                .replace(`{${"nodeName"}}`, encodeURIComponent(String(nodeName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;string&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(infoRequests || {}) : (infoRequests || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoOperationsApi - functional programming interface
 * @export
 */
export const InfoOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send a list of info commands to a random node in the cluster
         * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoAny(infoRequests: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = InfoOperationsApiFetchParamCreator(configuration).infoAny(infoRequests, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send a list of info commands to a specific node in the cluster.
         * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
         * @param {string} nodeName The node ID for the node which will receive the info commands.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoNode(infoRequests: Array<string>, nodeName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = InfoOperationsApiFetchParamCreator(configuration).infoNode(infoRequests, nodeName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InfoOperationsApi - factory interface
 * @export
 */
export const InfoOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Send a list of info commands to a random node in the cluster
         * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoAny(infoRequests: Array<string>, options?: any) {
            return InfoOperationsApiFp(configuration).infoAny(infoRequests, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send a list of info commands to a specific node in the cluster.
         * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
         * @param {string} nodeName The node ID for the node which will receive the info commands.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoNode(infoRequests: Array<string>, nodeName: string, options?: any) {
            return InfoOperationsApiFp(configuration).infoNode(infoRequests, nodeName, options)(fetch, basePath);
        },
    };
};

/**
 * InfoOperationsApi - object-oriented interface
 * @export
 * @class InfoOperationsApi
 * @extends {BaseAPI}
 */
export class InfoOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Send a list of info commands to a random node in the cluster
     * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoOperationsApi
     */
    public infoAny(infoRequests: Array<string>, options?: any) {
        return InfoOperationsApiFp(this.configuration).infoAny(infoRequests, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send a list of info commands to a specific node in the cluster.
     * @param {Array<string>} infoRequests An array of info commands to send to the server. See https://www.aerospike.com/docs/reference/info/ for a list of valid commands.
     * @param {string} nodeName The node ID for the node which will receive the info commands.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoOperationsApi
     */
    public infoNode(infoRequests: Array<string>, nodeName: string, options?: any) {
        return InfoOperationsApiFp(this.configuration).infoNode(infoRequests, nodeName, options)(this.fetch, this.basePath);
    }

}

/**
 * KeyValueOperationsApi - fetch parameter creator
 * @export
 */
export const KeyValueOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling createRecordNamespaceKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling createRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling createRecordNamespaceSetKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling createRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling createRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling deleteRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (bins) {
                localVarQueryParameter['bins'] = bins;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling getRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (bins) {
                localVarQueryParameter['bins'] = bins;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling recordExistsNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling recordExistsNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling recordExistsNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling recordExistsNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling recordExistsNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling replaceRecordNamespaceKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling replaceRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling replaceRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling updateRecordNamespaceKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeyValueOperationsApi - functional programming interface
 * @export
 */
export const KeyValueOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).createRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).createRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).deleteRecordNamespaceKey(key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).deleteRecordNamespaceSetKey(key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).getRecordNamespaceKey(key, namespace, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).getRecordNamespaceSetKey(key, namespace, set, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).recordExistsNamespaceKey(key, namespace, keytype, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).recordExistsNamespaceSetKey(key, namespace, set, keytype, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).replaceRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).replaceRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).updateRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).updateRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KeyValueOperationsApi - factory interface
 * @export
 */
export const KeyValueOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).createRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).createRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).deleteRecordNamespaceKey(key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).deleteRecordNamespaceSetKey(key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).getRecordNamespaceKey(key, namespace, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).getRecordNamespaceSetKey(key, namespace, set, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
            return KeyValueOperationsApiFp(configuration).recordExistsNamespaceKey(key, namespace, keytype, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
            return KeyValueOperationsApiFp(configuration).recordExistsNamespaceSetKey(key, namespace, set, keytype, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).replaceRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).replaceRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).updateRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).updateRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
    };
};

/**
 * KeyValueOperationsApi - object-oriented interface
 * @export
 * @class KeyValueOperationsApi
 * @extends {BaseAPI}
 */
export class KeyValueOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new record with the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).createRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new record with the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).createRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).deleteRecordNamespaceKey(key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).deleteRecordNamespaceSetKey(key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return the metadata and bins for a record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).getRecordNamespaceKey(key, namespace, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return the metadata and bins for a record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).getRecordNamespaceSetKey(key, namespace, set, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check if a record exists
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
        return KeyValueOperationsApiFp(this.configuration).recordExistsNamespaceKey(key, namespace, keytype, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check if a record exists
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
        return KeyValueOperationsApiFp(this.configuration).recordExistsNamespaceSetKey(key, namespace, set, keytype, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace the bins of the specified record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).replaceRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace the bins of the specified record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).replaceRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Merge the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).updateRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Merge the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).updateRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

}

/**
 * OperateOperationsApi - fetch parameter creator
 * @export
 */
export const OperateOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling operateNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling operateNamespaceKey.');
            }
            // verify required parameter 'operations' is not null or undefined
            if (operations === null || operations === undefined) {
                throw new RequiredError('operations','Required parameter operations was null or undefined when calling operateNamespaceKey.');
            }
            const localVarPath = `/v1/operate/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Operation&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(operations || {}) : (operations || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling operateNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling operateNamespaceSetKey.');
            }
            // verify required parameter 'operations' is not null or undefined
            if (operations === null || operations === undefined) {
                throw new RequiredError('operations','Required parameter operations was null or undefined when calling operateNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling operateNamespaceSetKey.');
            }
            const localVarPath = `/v1/operate/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Operation&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(operations || {}) : (operations || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperateOperationsApi - functional programming interface
 * @export
 */
export const OperateOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = OperateOperationsApiFetchParamCreator(configuration).operateNamespaceKey(key, namespace, operations, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = OperateOperationsApiFetchParamCreator(configuration).operateNamespaceSetKey(key, namespace, operations, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperateOperationsApi - factory interface
 * @export
 */
export const OperateOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return OperateOperationsApiFp(configuration).operateNamespaceKey(key, namespace, operations, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return OperateOperationsApiFp(configuration).operateNamespaceSetKey(key, namespace, operations, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
    };
};

/**
 * OperateOperationsApi - object-oriented interface
 * @export
 * @class OperateOperationsApi
 * @extends {BaseAPI}
 */
export class OperateOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Perform multiple operations atomically on the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperateOperationsApi
     */
    public operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return OperateOperationsApiFp(this.configuration).operateNamespaceKey(key, namespace, operations, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Perform multiple operations atomically on the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperateOperationsApi
     */
    public operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return OperateOperationsApiFp(this.configuration).operateNamespaceSetKey(key, namespace, operations, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

}

/**
 * SecondaryIndexMethodsApi - fetch parameter creator
 * @export
 */
export const SecondaryIndexMethodsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a secondary index.
         * @param {RestClientIndex} indexModel indexModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex(indexModel: RestClientIndex, options: any = {}): FetchArgs {
            // verify required parameter 'indexModel' is not null or undefined
            if (indexModel === null || indexModel === undefined) {
                throw new RequiredError('indexModel','Required parameter indexModel was null or undefined when calling createIndex.');
            }
            const localVarPath = `/v1/index`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RestClientIndex" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(indexModel || {}) : (indexModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a secondary Index
         * @param {string} name The name of the index
         * @param {string} namespace The namespace containing the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropIndex(name: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling dropIndex.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling dropIndex.');
            }
            const localVarPath = `/v1/index/{namespace}/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Information about a single secondary index.
         * @param {string} name The name of the index
         * @param {string} namespace The namespace containing the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexStats(name: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getIndexStats.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getIndexStats.');
            }
            const localVarPath = `/v1/index/{namespace}/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return information about multiple secondary indices.
         * @param {string} [namespace] If specified, the list of returned indices will only contain entries from this namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexInformation(namespace?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/index`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecondaryIndexMethodsApi - functional programming interface
 * @export
 */
export const SecondaryIndexMethodsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a secondary index.
         * @param {RestClientIndex} indexModel indexModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex(indexModel: RestClientIndex, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SecondaryIndexMethodsApiFetchParamCreator(configuration).createIndex(indexModel, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a secondary Index
         * @param {string} name The name of the index
         * @param {string} namespace The namespace containing the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropIndex(name: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SecondaryIndexMethodsApiFetchParamCreator(configuration).dropIndex(name, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Information about a single secondary index.
         * @param {string} name The name of the index
         * @param {string} namespace The namespace containing the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexStats(name: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = SecondaryIndexMethodsApiFetchParamCreator(configuration).getIndexStats(name, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return information about multiple secondary indices.
         * @param {string} [namespace] If specified, the list of returned indices will only contain entries from this namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexInformation(namespace?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RestClientIndex>> {
            const localVarFetchArgs = SecondaryIndexMethodsApiFetchParamCreator(configuration).indexInformation(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecondaryIndexMethodsApi - factory interface
 * @export
 */
export const SecondaryIndexMethodsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a secondary index.
         * @param {RestClientIndex} indexModel indexModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex(indexModel: RestClientIndex, options?: any) {
            return SecondaryIndexMethodsApiFp(configuration).createIndex(indexModel, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a secondary Index
         * @param {string} name The name of the index
         * @param {string} namespace The namespace containing the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropIndex(name: string, namespace: string, options?: any) {
            return SecondaryIndexMethodsApiFp(configuration).dropIndex(name, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Information about a single secondary index.
         * @param {string} name The name of the index
         * @param {string} namespace The namespace containing the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexStats(name: string, namespace: string, options?: any) {
            return SecondaryIndexMethodsApiFp(configuration).getIndexStats(name, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return information about multiple secondary indices.
         * @param {string} [namespace] If specified, the list of returned indices will only contain entries from this namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexInformation(namespace?: string, options?: any) {
            return SecondaryIndexMethodsApiFp(configuration).indexInformation(namespace, options)(fetch, basePath);
        },
    };
};

/**
 * SecondaryIndexMethodsApi - object-oriented interface
 * @export
 * @class SecondaryIndexMethodsApi
 * @extends {BaseAPI}
 */
export class SecondaryIndexMethodsApi extends BaseAPI {
    /**
     * 
     * @summary Create a secondary index.
     * @param {RestClientIndex} indexModel indexModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryIndexMethodsApi
     */
    public createIndex(indexModel: RestClientIndex, options?: any) {
        return SecondaryIndexMethodsApiFp(this.configuration).createIndex(indexModel, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a secondary Index
     * @param {string} name The name of the index
     * @param {string} namespace The namespace containing the index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryIndexMethodsApi
     */
    public dropIndex(name: string, namespace: string, options?: any) {
        return SecondaryIndexMethodsApiFp(this.configuration).dropIndex(name, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Information about a single secondary index.
     * @param {string} name The name of the index
     * @param {string} namespace The namespace containing the index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryIndexMethodsApi
     */
    public getIndexStats(name: string, namespace: string, options?: any) {
        return SecondaryIndexMethodsApiFp(this.configuration).getIndexStats(name, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return information about multiple secondary indices.
     * @param {string} [namespace] If specified, the list of returned indices will only contain entries from this namespace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryIndexMethodsApi
     */
    public indexInformation(namespace?: string, options?: any) {
        return SecondaryIndexMethodsApiFp(this.configuration).indexInformation(namespace, options)(this.fetch, this.basePath);
    }

}

/**
 * TruncateOperationsApi - fetch parameter creator
 * @export
 */
export const TruncateOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Truncate records in a specified namespace.
         * @param {string} namespace The namespace whose records will be truncated.
         * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateNamespace(namespace: string, date?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling truncateNamespace.');
            }
            const localVarPath = `/v1/truncate/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Truncate records in a specified namespace and set.
         * @param {string} namespace The namespace whose records will be truncated
         * @param {string} set The set, in the specified namespace, whose records will be truncated
         * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateSet(namespace: string, set: string, date?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling truncateSet.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling truncateSet.');
            }
            const localVarPath = `/v1/truncate/{namespace}/{set}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TruncateOperationsApi - functional programming interface
 * @export
 */
export const TruncateOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Truncate records in a specified namespace.
         * @param {string} namespace The namespace whose records will be truncated.
         * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateNamespace(namespace: string, date?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TruncateOperationsApiFetchParamCreator(configuration).truncateNamespace(namespace, date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Truncate records in a specified namespace and set.
         * @param {string} namespace The namespace whose records will be truncated
         * @param {string} set The set, in the specified namespace, whose records will be truncated
         * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateSet(namespace: string, set: string, date?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TruncateOperationsApiFetchParamCreator(configuration).truncateSet(namespace, set, date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TruncateOperationsApi - factory interface
 * @export
 */
export const TruncateOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Truncate records in a specified namespace.
         * @param {string} namespace The namespace whose records will be truncated.
         * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateNamespace(namespace: string, date?: string, options?: any) {
            return TruncateOperationsApiFp(configuration).truncateNamespace(namespace, date, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Truncate records in a specified namespace and set.
         * @param {string} namespace The namespace whose records will be truncated
         * @param {string} set The set, in the specified namespace, whose records will be truncated
         * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateSet(namespace: string, set: string, date?: string, options?: any) {
            return TruncateOperationsApiFp(configuration).truncateSet(namespace, set, date, options)(fetch, basePath);
        },
    };
};

/**
 * TruncateOperationsApi - object-oriented interface
 * @export
 * @class TruncateOperationsApi
 * @extends {BaseAPI}
 */
export class TruncateOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Truncate records in a specified namespace.
     * @param {string} namespace The namespace whose records will be truncated.
     * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TruncateOperationsApi
     */
    public truncateNamespace(namespace: string, date?: string, options?: any) {
        return TruncateOperationsApiFp(this.configuration).truncateNamespace(namespace, date, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Truncate records in a specified namespace and set.
     * @param {string} namespace The namespace whose records will be truncated
     * @param {string} set The set, in the specified namespace, whose records will be truncated
     * @param {string} [date] All records last updated before this date/time will be truncated. If not specified, all records will be truncated. This is a string representation of a date time utilizing the ISO-8601 extended offset date-time format. example: 2019-12-03T10:15:30+01:00
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TruncateOperationsApi
     */
    public truncateSet(namespace: string, set: string, date?: string, options?: any) {
        return TruncateOperationsApiFp(this.configuration).truncateSet(namespace, set, date, options)(this.fetch, this.basePath);
    }

}

